# 팩토리얼 끝자리 0의 개수
[백준 1676](https://www.acmicpc.net/problem/1676)
<details>
<summary>시간초과 (시간 제한 2초) + <span style="color:red; font-weight:bold;"> 실행 시간 예측하는 법</span></summary>
<div markdown="1">


```java
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int n = sc.nextInt();
    int f = 1;
    for(int i = n; i > 0; i--) {
        f *= i;
    }

    int temp = f % 10;
    int result = 0;
    while(temp == 0) {
        result++;
        f /= 10;
        temp = f % 10;
    }

    System.out.println(result);
    }
}
```

시간복잡도는?

1. for문
    
    ```java
    for(int i = n; i > 0; i--) {
            f *= i;
        }
    ```
    
    O(n)
    
2. while문
    
    ```java
    while(temp == 0) {
            result++;
            f /= 10;
            temp = f % 10;
        }
    ```
    
    팩토리얼 `n!`의 끝자리 0의 개수는 주로 `n`에 포함된 5의 배수의 수에 의해 결정되므로, 이 루프의 반복 횟수는 대략적으로 O(log f)와 비슷합니다. 하지만 이는 크게 보면 `n`에 포함된 5의 개수에 해당하고, 그 수는 일반적으로 매우 작습니다. 실제로는 팩토리얼의 크기에 따라 시간이 달라질 수 있습니다.
    
    O(logf)
    

즉, O(n + logf) 인데, `f`의 크기는 `n`에 따라 지수적으로 커지므로, 최종적으로는 **O(n)** 이 지배적

시간복잡도 시간은?

> **2초 이상** 걸릴지 **안 넘을지 예측**하는 방법은 다음과 같은 **3가지 주요 기준**에 따라 판단할 수 있습니다.
> 
> 
> ### 1. **시간 복잡도를 기반으로 한 예상 연산 횟수 계산**:
> 
> 우선, 코드의 시간 복잡도를 계산한 뒤, 입력 크기에 따라 총 연산 횟수를 추산할 수 있습니다. 이를 통해 예상 시간을 추정하게 됩니다.
> 
> - 일반적으로 **1초당 10^8번의 연산**을 처리할 수 있다고 가정합니다.
> - 만약 코드가 O(n) 시간 복잡도를 가진다면, 입력 `n`에 따라 **n번의 연산**을 한다고 가정하고, 이를 **10^8**로 나누어 시간이 얼마나 걸릴지 대략적으로 추산합니다.
> 
> ### 예시:
> 
> - `n = 500`일 때 O(n) 알고리즘이라면, 대략 **500번의 연산**이 발생합니다.
> - 이 경우 500 ÷ 10^8 ≈ **5 마이크로초**이므로 매우 빠르게 끝납니다.
> 
> 하지만 이 방식은 단순한 연산에서만 적용될 수 있습니다. **복잡한 연산**(예: 큰 수 연산, 나누기, 곱하기 등)이 들어가면 시간 복잡도만으로는 충분하지 않습니다.
> 
> ### 2. **큰 수 연산에서의 추가 시간 고려**:
> 
> 단순히 반복문만의 시간이 아니라, **내부에서 큰 수를 다룰 때** 시간이 더 걸릴 수 있다는 것을 고려해야 합니다.
> 
> 예를 들어, `500!` 같은 큰 수는 1135자리 이상의 숫자이므로, 이런 큰 수를 나누거나 나머지를 구하는 연산은 더 많은 시간이 소요됩니다. 이때 큰 수 연산의 비용은 보통 **자리 수에 비례**하므로 O(k)와 같은 비용이 발생합니다.
> 
> 따라서 **500!**에서 10으로 나눠가며 끝자리 0을 세는 연산에서는, 그 크기 때문에 시간 복잡도가 실제로는 **단순한 O(n)보다 훨씬 더 높아질 수 있습니다**. 이렇게 큰 수 연산이 자주 포함된 경우, 연산 비용을 더 높게 잡아야 합니다.
> 
> ### 3. **실험적 테스트 및 예측 도구 활용**:
> 
> - 코드를 직접 실행해보고, 입력 크기를 늘려가며 **소요 시간을 측정**하는 방법이 있습니다.
> - 작은 입력값에서의 시간 소요를 보고, 이를 기반으로 더 큰 입력값에 대해 **예측**할 수 있습니다.
> 
> 만약 **n = 500**일 때 1초가 걸렸다면, 이를 바탕으로 비슷한 크기의 입력에 대해 얼마나 시간이 더 걸릴지 쉽게 예측할 수 있습니다.
> 
> ---
> 
> 정리하자면, 코드가 2초를 넘길지 예측하는 방법은:
> 
> 1. **시간 복잡도**를 기반으로 입력 크기와 연산 횟수를 계산.
> 2. *복잡한 연산(특히 큰 수 연산)**이 포함된 경우 실제로 더 많은 시간이 소요될 수 있다는 점을 고려.
> 3. **실제 실험적 실행**으로 작은 입력에서 시간 소요를 확인하고 추정.
> 
> 이 세 가지 기준을 사용하면, 코드가 2초를 초과할지 미리 예측할 수 있습니다.
> 

위 문제에서 최악의 경우는 500!일 때, 1135이상의 수라는 어마무시하게 큰 수를 나누어서 많은 시간이 소요 된다.

</div>
</details>
</br>
</br>


팩토리얼을 직접 계산하는 방식은 시간 초과를 발생시킨다. 팩토리얼 값이 매우빠르게 커져, 큰 수를 계산하고 저장하는데 시간이 많이 소요되기 때문이다. 특히 최악의 경우인 500!은 매우 큰 값이므로 메모리와 계산 성능에 부담이 된다.

### 문제의 핵심

- 500!은 엄청 큰 수로 0이 몇개 있는지만 구하는 문제에서 굳이 모든 책토리얼을 계산할 필요가 없다!
- 끝자리 0의 개수는 2와 5의 곱으로 만들어지므로, 팩토리얼에서 나오는 **5의 배수**만 신경쓰면 된다!
    - 2는 왜 신경을 안쓰나요?
        
        왜냐하면 2의 배수는 항상 충분히 많이 나오기 때문!(물론, 5의 배수보다 더 많이~~~!)
        
- 즉, **팩토리얼 값을 전부 계산하지 않아도** 끝자리 0이 개수를 구할 수 있다. 5의 배수가 나올 때마다 끝자리 0이 추가된다는 사실을 이용!!!!!!

### 그래서 정답은 : n!에서 5의 배수들을 세는 것

예를 들어, 25!에서 끝에 나오는 0의 개수를 알고 싶다면,

1. 25 이하의 5의 배수는 5, 10, 15, 20, 25 이다.
2. 여기서 5의 배수가 5개 있으므로 적어도 5개의 0이 끝에 추가된다.
3. 추가로, 25는 5^2이므로, 여기에서 한 번 더 5를 제공해서 0 하나가 더 추가된다.

즉, 25!의 끝자리 0의 개수는 총 6개!

이러한 원리로 코드를 작성하면 된다.

* 정답 코드
```java
import java.util.Scanner;

public class Main {

  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int n = sc.nextInt();
    int result = 0;

    // n!에서 끝에 붙는 0의 개수를 구하기 위해 5의 배수 개수를 셈
    for (int i = 5; i <= n; i *= 5) {
      result += n / i;
    }

    System.out.println(result);
  }
}
```
- 시간 복잡도
    - n을 5로 나누는 횟수만큼 반복되어 O(log₅ n)의 시간복잡도를 갖는다.